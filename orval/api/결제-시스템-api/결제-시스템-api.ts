/**
 * Generated by orval v6.16.0 ğŸº
 * Do not edit manually.
 * Hi Kitty í”„ë¡œì íŠ¸!!
 * Hi Kittyì˜ API ëª…ì„¸ì„œì…ë‹ˆë‹¤.
 * OpenAPI spec version: v1
 */
import {
  useQuery,
  useMutation
} from 'react-query'
import type {
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from 'react-query'
import type {
  ApiResultOrderResponse,
  OrderRequest,
  ApiResultCompleteResponse,
  ApiResultPaymentResponse,
  SuccessParams,
  ApiResultPaymentFailRequest,
  FailParams
} from '../../model'
import { customInstance } from '../../../api/axios';


// eslint-disable-next-line
  type SecondParameter<T extends (...args: any) => any> = T extends (
  config: any,
  args: infer P,
) => any
  ? P
  : never;

/**
 * ê¸°ë¶€í•˜ê¸° ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ í•´ë‹¹ APIë¥¼ ì „ì†¡í•´ì„œ ì‘ë‹µ ê°’ì„ ë°›ìœ¼ì„¸ìš”.
 * @summary ê²°ì œ ìš”ì²­
 */
export const request = (
    orderRequest: OrderRequest,
 options?: SecondParameter<typeof customInstance>,) => {
      return customInstance<ApiResultOrderResponse>(
      {url: `/api/v1/payments/request`, method: 'post',
      headers: {'Content-Type': 'application/json', },
      data: orderRequest
    },
      options);
    }
  


export const getRequestMutationOptions = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof request>>, TError,{data: OrderRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof request>>, TError,{data: OrderRequest}, TContext> => {
 const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof request>>, {data: OrderRequest}> = (props) => {
          const {data} = props ?? {};

          return  request(data,requestOptions)
        }

        

 
   return  { mutationFn, ...mutationOptions }}

    export type RequestMutationResult = NonNullable<Awaited<ReturnType<typeof request>>>
    export type RequestMutationBody = OrderRequest
    export type RequestMutationError = unknown

    /**
 * @summary ê²°ì œ ìš”ì²­
 */
export const useRequest = <TError = unknown,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof request>>, TError,{data: OrderRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
    
      const mutationOptions = getRequestMutationOptions(options);
     
      return useMutation(mutationOptions);
    }
    /**
 * ê²°ì œ ì™„ë£Œì‹œ ë§ˆì§€ë§‰ìœ¼ë¡œ ì‚¬ìš©ìì—ê²Œ ì•Œë¦°ë‹¤.
 * @summary ê²°ì œ ì™„ë£Œ ê²°ê³¼ ì°½
 */
export const complete = (
    orderId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      return customInstance<ApiResultCompleteResponse>(
      {url: `/api/v1/payments/${orderId}`, method: 'get', signal
    },
      options);
    }
  

export const getCompleteQueryKey = (orderId: string,) => [`/api/v1/payments/${orderId}`] as const;
  

    
export const getCompleteQueryOptions = <TData = Awaited<ReturnType<typeof complete>>, TError = unknown>(orderId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof complete>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof complete>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCompleteQueryKey(orderId);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof complete>>> = ({ signal }) => complete(orderId, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, enabled: !!(orderId), ...queryOptions}}

export type CompleteQueryResult = NonNullable<Awaited<ReturnType<typeof complete>>>
export type CompleteQueryError = unknown

/**
 * @summary ê²°ì œ ì™„ë£Œ ê²°ê³¼ ì°½
 */
export const useComplete = <TData = Awaited<ReturnType<typeof complete>>, TError = unknown>(
 orderId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof complete>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getCompleteQueryOptions(orderId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

/**
 * ê²°ì œ ì„±ê³µ ì‹œ ìµœì¢… ê²°ì œ ìŠ¹ì¸ ìš”ì²­ì„ ë³´ë‚¸ë‹¤.
 * @summary ê²°ì œ ì„±ê³µ ë¦¬ë‹¤ì´ë ‰íŠ¸
 */
export const success = (
    params: SuccessParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      return customInstance<ApiResultPaymentResponse>(
      {url: `/api/v1/payments/success`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getSuccessQueryKey = (params: SuccessParams,) => [`/api/v1/payments/success`, ...(params ? [params]: [])] as const;
  

    
export const getSuccessQueryOptions = <TData = Awaited<ReturnType<typeof success>>, TError = unknown>(params: SuccessParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof success>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof success>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSuccessQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof success>>> = ({ signal }) => success(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type SuccessQueryResult = NonNullable<Awaited<ReturnType<typeof success>>>
export type SuccessQueryError = unknown

/**
 * @summary ê²°ì œ ì„±ê³µ ë¦¬ë‹¤ì´ë ‰íŠ¸
 */
export const useSuccess = <TData = Awaited<ReturnType<typeof success>>, TError = unknown>(
 params: SuccessParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof success>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getSuccessQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

/**
 * ê²°ì œ ì‹¤íŒ¨ ì‹œ ìµœì¢… ê²°ì œ ìŠ¹ì¸ ìš”ì²­ì„ ë³´ë‚¸ë‹¤.
 * @summary ê²°ì œ ì‹¤íŒ¨ ë¦¬ë‹¤ì´ë ‰íŠ¸
 */
export const fail = (
    params: FailParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      return customInstance<ApiResultPaymentFailRequest>(
      {url: `/api/v1/payments/fail`, method: 'get',
        params, signal
    },
      options);
    }
  

export const getFailQueryKey = (params: FailParams,) => [`/api/v1/payments/fail`, ...(params ? [params]: [])] as const;
  

    
export const getFailQueryOptions = <TData = Awaited<ReturnType<typeof fail>>, TError = unknown>(params: FailParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fail>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
): UseQueryOptions<Awaited<ReturnType<typeof fail>>, TError, TData> & { queryKey: QueryKey } => {
const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFailQueryKey(params);

  
  
    const queryFn: QueryFunction<Awaited<ReturnType<typeof fail>>> = ({ signal }) => fail(params, requestOptions, signal);
    
      
      
   return  { queryKey, queryFn, ...queryOptions}}

export type FailQueryResult = NonNullable<Awaited<ReturnType<typeof fail>>>
export type FailQueryError = unknown

/**
 * @summary ê²°ì œ ì‹¤íŒ¨ ë¦¬ë‹¤ì´ë ‰íŠ¸
 */
export const useFail = <TData = Awaited<ReturnType<typeof fail>>, TError = unknown>(
 params: FailParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fail>>, TError, TData>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getFailQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

